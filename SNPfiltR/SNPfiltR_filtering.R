################################################################################
## Datafiles and Directories ##
## Set up an object containing the path to the data ##
library(tidyverse)
library(tidyr)
library(dplyr)

## SNPfiltR packages ##
library(SNPfiltR)
library(vcfR)

################################################################################
############################## DATA DIRECTORIES ################################
################################################################################

## Working Directory ##
data_dir <- "/datadir/" 
#data_dir <- getwd()
data_dir

basefile <- "noreponly_v2"

## Output Directory ##
filteredVCF <- paste0(data_dir, "/filteredVCF_ab")
filteredVCF

if(!dir.exists(filteredVCF)){ # check if the directory exists
  dir.create(filteredVCF)  } # and create it if it does not

# norep_nolowloci: All 3RADmerged samples excluding repeated individuals and indiv. with low loci - 256 individuals ##
#basefile <- "norep_nolowloci"

################################################################################
## Set as our working directory ##
setwd(data_dir)

################################################################################
## File Paths ##
## Ipyrad output vcf ##
#path_vcf<-paste0(data_dir,"/", basefile,".vcf.gz")
  
## Get in MetaData ## 
#md_csv<-paste0(data_dir,"/", basefile,"_metadata.csv")

#md <- read_csv(md_csv)
md <- read_csv("/home/hwsung/lus_scratch/R_data/noreponly_v2/noreponly_metadata.csv")
names(md)
  
# make dataframe for 'population' later
glimpse(md)
md
pops <- md %>% dplyr::select(CrocID, New_ID, Sample, Morph_Species, Longitude, Latitude, Monitoring.Unit, Abbrv_Monitoring.Unit, Route, Site, Subdivision)
pops
names(pops)

################################################################################
########################### SNPfiltR: SNP FILTERING ############################
################################################################################
#import filtered vcf file as new vcfR object 
vcfR <- read.vcfR(path_vcf) 
################################################################################
  
# Generate popmap file. Two column popmap with the same format as stacks, and the 
# columns must be named 'id' and 'pop'

# For Monitoring Unit
popmap_mont.unit <- pops %>% dplyr::select(Sample, Monitoring.Unit)
names(popmap_mont.unit) <- c("id", "pop")
popmap_mont.unit <- as.data.frame(popmap_mont.unit)
popmap_mont.unit
levels(as.factor(popmap_mont.unit$pop))

# For Morph_species 
popmap_morphsp <- pops %>% dplyr::select(Sample, Morph_Species)
names(popmap_morphsp) <- c("id", "pop")
popmap_morphsp <- as.data.frame(popmap_morphsp)
popmap_morphsp
  
################################################################################
################################################################################
### We will start by determining which samples contain too few sequences to be
# used in downstream analyses, by visualizing missing data per sample

#subset popmap to only include retained individuals
popmap_mont.unit<-popmap_mont.unit[popmap_mont.unit$id %in% colnames(vcfR@gt),]
dim(popmap_mont.unit)

#subset popmap_morphsp to only include retained individuals
popmap_morphsp<-popmap_morphsp[popmap_morphsp$id %in% colnames(vcfR@gt),]
dim(popmap_morphsp)

# run function to visualize samples
pdf("SNPfilt_missing_by_sample.pdf")
missing_by_sample(vcfR=vcfR, popmap = popmap_mont.unit)
missing_by_sample(vcfR=vcfR, popmap = popmap_morphsp)
dev.off()

### Now we can try setting a reasonable threshold, and then visualizing clustering 
# patterns to determine whether there are still problematic samples with excess
# missing data that can't be accurately assigned to genetic clusters

#run function to drop samples above the threshold we want from the vcf
vcfR<-missing_by_sample(vcfR=vcfR, cutoff = .80)

#subset popmap to only include retained individuals
popmap_mont.unit<-popmap_mont.unit[popmap_mont.unit$id %in% colnames(vcfR@gt),]
dim(popmap_mont.unit)

#subset popmap_morphsp to only include retained individuals
popmap_morphsp<-popmap_morphsp[popmap_morphsp$id %in% colnames(vcfR@gt),]
dim(popmap_morphsp)

# Write .csv file for the removed samples 
popmap <- pops %>% dplyr::select(Sample, Morph_Species, Monitoring.Unit)
popmap
names(popmap)[1] <- "id"

removed_samples <- popmap$id[which(!popmap$id %in% popmap_mont.unit$id)]
removed_samples <- as_tibble(removed_samples)
names(removed_samples) <- "Sample"

removed_samples <- removed_samples %>%
  left_join(pops, by = "Sample")

write.csv(removed_samples, file = "removed_samples.csv", row.names = FALSE)

# remove invariant sites generated by dropping individuals
vcfR<-min_mac(vcfR, min.mac = 1)
vcfR # 206,111 variants

################################################################################
### NOTE: don't do next step if file is huge, export first and retry on smaller file 
################################################################################
# Export file first 
filteredsample_vcf <-paste0(filteredVCF,"/", basefile,".filtered.step3.vcf.gz")
vcfR::write.vcf(vcfR, filteredsample_vcf)

################################################################################
## Continue on smaller filtered file ## 
# import filtered vcf file as new vcfR object 
filteredsample_vcf <-paste0(data_dir,"/", basefile,".filtered.step3_ab.vcf.gz")
vcfR <- read.vcfR(filteredsample_vcf)   # For filtered vcf file

#subset popmap to only include retained individuals
popmap_mont.unit<-popmap_mont.unit[popmap_mont.unit$id %in% colnames(vcfR@gt),]
dim(popmap_mont.unit)

#subset popmap_morphsp to only include retained individuals
popmap_morphsp<-popmap_morphsp[popmap_morphsp$id %in% colnames(vcfR@gt),]
dim(popmap_morphsp)

#run function to visualize samples and return informative data.frame object
pdf("SNPfilt_missing_by_sample_step3.pdf")
miss<-missing_by_sample(vcfR=vcfR)
dev.off()

# run function to visualize samples
pdf("SNPfilt_missing_by_sample_monit_unit.pdf")
missing_by_sample(vcfR=vcfR, popmap = popmap_mont.unit)
dev.off()

pdf("SNPfilt_missing_by_sample_morph_sp.pdf")
missing_by_sample(vcfR=vcfR, popmap = popmap_morphsp)
dev.off()

#verify that missing data is not driving clustering patterns among the retained samples
SNPfilt_Step3PCA <-paste0(filteredVCF,"/", basefile, "_SNPfilt_Step3_PCA.pdf")
pdf(SNPfilt_Step3PCA)
miss_mont.unit<-assess_missing_data_pca(vcfR=vcfR, popmap = popmap_mont.unit, thresholds = .8, clustering = FALSE)
miss_morphsp<-assess_missing_data_pca(vcfR=vcfR, popmap = popmap_morphsp, thresholds = .8, clustering = FALSE)
dev.off()


################################################################################
## Reran Steps 1-3: ## 
#run function to visualize samples and return informative data.frame object
pdf("SNPfilt_missing_by_sample_step3_ab.pdf")
miss<-missing_by_sample(vcfR=vcfR)
missing_by_sample(vcfR=vcfR, popmap = popmap_morphsp)
missing_by_sample(vcfR=vcfR, popmap = popmap_mont.unit)
dev.off()
  # there is still a few samples with extremely high depth 

#show me the samples with the most missing data at a 60% completeness threshold
vcfR_60<-missing_by_sample(vcfR=vcfR, cutoff = .60)
miss<-missing_by_sample(vcfR=vcfR_60)

filt<-miss[miss$filt == .60,]
filt[order(filt$snps.retained),]

missing_by_snp(vcfR_60)

#remove invariant sites generated by dropping individuals
vcfR<-min_mac(vcfR_60, min.mac = 1)

#subset popmap to only include retained individuals
popmap_mont.unit<-popmap_mont.unit[popmap_mont.unit$id %in% colnames(vcfR@gt),]
dim(popmap_mont.unit)

#subset popmap_morphsp to only include retained individuals
popmap_morphsp<-popmap_morphsp[popmap_morphsp$id %in% colnames(vcfR@gt),]
dim(popmap_morphsp)

#verify that missing data is not driving clustering patterns among the retained samples
SNPfilt_Step3PCA <-paste0(filteredVCF,"/", basefile, "_SNPfilt_Step3_PCA.pdf")
pdf(SNPfilt_Step3PCA)
miss_mont.unit<-assess_missing_data_pca(vcfR=vcfR, popmap = popmap_mont.unit, thresholds = 7, clustering = FALSE)
miss_morphsp<-assess_missing_data_pca(vcfR=vcfR, popmap = popmap_morphsp, thresholds = .7, clustering = FALSE)
dev.off()

#if there are still problematic samples, drop them using the following syntax
#vcfR <- vcfR[,colnames(vcfR@gt) != "A_woodhouseii_24711" & colnames(vcfR@gt) != "A_californica_45901"]


################################################################################
# Step 4: set missing data per SNP cutoff

### Set arbitrary cutoff for missing data allowed per SNP.

#### We can visualize the effect that typical missing data cutoffs will have on 
# both the number of SNPs retained and the total missing data in our entire dataset.
# We want to choose a cutoff that minimizes the overall missing data in the dataset, 
# while maximizing the total number of loci retained.

### Note: 
# This filter interacts with the above filter, where we dropped low data samples. 
# A good rule of thumb is that individual samples shouldn't be above 50% missing 
# data after applying a per-SNP missing data cutoff. So if we are retaining specific 
# low data samples out of necessity or project design, we may have to set a more 
# stringent per-SNP missing data cutoff, at the expense of the total number of 
# SNPs retained for downstream analyses. We can again use the assess_missing_data_pca() 
# function to determine whether all retained samples contain enough data at our 
# chosen cutoff in order to be assigned accurately to their species group.

#visualize missing data by SNP and the effect of various cutoffs on the missingness of each sample
miss_snp_fig <-paste0(filteredVCF,"/", basefile, "_missingbySNP",".pdf")
pdf(file=miss_snp_fig, width=8, height=8)
missing_by_snp(vcfR)
dev.off()


## Double check for problematic samples and remove by hand ##
## samples with an excess of missing data are leaking toward the center indicate 
# that they canâ€™t be reliably clustered due to excess missing data. We can go back 
# and target specific samples with too much missing data even at high filtering 
# thresholds for removal using the following code:
#show me the samples with the most missing data at an 80% completeness threshold
filt<-miss[miss$filt == .8,]
filt[order(filt$snps.retained),]

# drop the samples with an excess of missing data at an 80% SNP completeness threshold
vcfR<- vcfR[,colnames(vcfR@gt) != "HS_P1_A11" & colnames(vcfR@gt) != "HS_P4_F1" & colnames(vcfR@gt) != "HS_P1_F9"]

#remove invariant SNPs
vcfR<-min_mac(vcfR, min.mac = 1)

#subset popmap to only include retained individuals
popmap_mont.unit<-popmap_mont.unit[popmap_mont.unit$id %in% colnames(vcfR@gt),]
dim(popmap_mont.unit)

#subset popmap_morphsp to only include retained individuals
popmap_morphsp<-popmap_morphsp[popmap_morphsp$id %in% colnames(vcfR@gt),]
dim(popmap_morphsp)

## Don't do if file is huge 
#check if these cutoffs prevent samples from clustering
#by patterns of missing data in a PCA
PCAfig <-paste0(filteredVCF,"/", basefile,"_PCA_missingthresholds",".pdf")
pdf(file=PCAfig, width=8, height=8)
miss_mont.unit<-assess_missing_data_pca(vcfR=vcfR, popmap = popmap_mont.unit,
                                        thresholds = c(.75,.80,.85,.90,.95), clustering = FALSE)
miss_morphsp<-assess_missing_data_pca(vcfR=vcfR, popmap = popmap_morphsp,
                                      thresholds = c(.75,.80,.85,.90,.95), clustering = FALSE)
dev.off() 

#check what t-SNE clustering looks like at different thresholds
tSNEfig <-paste0(filteredVCF,"/", basefile,"_tSNE_thresholds",".pdf")
pdf(file=tSNEfig, width=8, height=8)
tSNE_miss_mont.unit<-assess_missing_data_tsne(vcfR=vcfR, popmap = popmap_mont.unit,
                                              thresholds = c(.75,.80,.85,.90,.95), clustering = FALSE)
tSNE_miss_morphsp<-assess_missing_data_tsne(vcfR=vcfR, popmap = popmap_morphsp,
                                            thresholds = c(.75,.80,.85,.90,.95), clustering = FALSE)
dev.off()


#choose a cutoff resulting in an acceptable amount of missing data in each sample, 
# and maximizes SNPs retained while minimizing overall missing data, and filter vcf
miss_snp_fig_75.95 <-paste0(filteredVCF,"/", basefile, "_missingbySNP_75-95",".pdf")
pdf(file=miss_snp_fig_75.95, width=8, height=8)
vcfR.75<-missing_by_snp(vcfR, cutoff = .75)
vcfR.80<-missing_by_snp(vcfR, cutoff = .80)
vcfR.85<-missing_by_snp(vcfR, cutoff = .85)
vcfR.95<-missing_by_snp(vcfR, cutoff = .95)
dev.off()

#check how many SNPs and samples are left
vcfR.75
vcfR.80
vcfR.85
vcfR.95

#plot depth per snp and per sample
dp.per.snp <-paste0(filteredVCF,"/",basefile, "_SNPdepth_per_sample_heatmap",".pdf")

pdf(file=dp.per.snp, width=8, height=8)
dp.75 <- extract.gt(vcfR.75, element = "DP", as.numeric=TRUE)
heatmap.bp(dp.75, rlabels = FALSE)

dp.80 <- extract.gt(vcfR.80, element = "DP", as.numeric=TRUE)
heatmap.bp(dp.80, rlabels = FALSE)

dp.85 <- extract.gt(vcfR.85, element = "DP", as.numeric=TRUE)
heatmap.bp(dp.85, rlabels = FALSE)

dp.95 <- extract.gt(vcfR.95, element = "DP", as.numeric=TRUE)
heatmap.bp(dp.95, rlabels = FALSE)
dev.off()


#show me the samples with the most missing data at an 60% completeness threshold
vcfR.75 <- missing_by_sample(vcfR=vcfR.75, cutoff = 0.6)
vcfR.80 <- missing_by_sample(vcfR=vcfR.80, cutoff = 0.6)
vcfR.85 <- missing_by_sample(vcfR=vcfR.85, cutoff = 0.6)
vcfR.95 <- missing_by_sample(vcfR=vcfR.95, cutoff = 0.6)

#remove invariant sites generated by dropping individuals
vcfR.75<-min_mac(vcfR.75, min.mac = 1)
vcfR.80<-min_mac(vcfR.80, min.mac = 1)
vcfR.85<-min_mac(vcfR.85, min.mac = 1)
vcfR.95<-min_mac(vcfR.95, min.mac = 1)

#write out vcf for bigger datasets and go through again 
filteredVCF
filtered75_vcf <-paste0(filteredVCF,"/", basefile,".filtered.75.vcf.gz")
vcfR::write.vcf(vcfR.75, filtered75_vcf)

filtered80_vcf <-paste0(filteredVCF,"/", basefile,".filtered.80.vcf.gz")
vcfR::write.vcf(vcfR.80, filtered80_vcf)

filtered85_vcf <-paste0(filteredVCF,"/", basefile,".filtered.85.vcf.gz")
vcfR::write.vcf(vcfR.85, filtered85_vcf)

filtered95_vcf <-paste0(filteredVCF,"/", basefile,".filtered.95.vcf.gz")
vcfR::write.vcf(vcfR.95, filtered95_vcf)

################################################################################
## Make .csv of removed individuals at each threshold ## 
################################################################################
vcfR <- vcfR.75

#subset popmap to only include retained individuals
popmap_mont.unit<-popmap_mont.unit[popmap_mont.unit$id %in% colnames(vcfR@gt),]
dim(popmap_mont.unit)

#subset popmap_morphsp to only include retained individuals
popmap_morphsp<-popmap_morphsp[popmap_morphsp$id %in% colnames(vcfR@gt),]
dim(popmap_morphsp)

popmap <- pops %>% dplyr::select(Sample, Morph_Species, Monitoring.Unit)
popmap
names(popmap) <- c("id", "pop", "MU")

sample_vcfR <- popmap$id
popsample <- popmap_mont.unit$id
removed_id <- sample_vcfR[which(!sample_vcfR %in% popsample)]
removed_samples <- as_tibble(removed_id)
names(removed_samples) <- "Sample"

removed_samples <- removed_samples %>%
  left_join(pops, by = "Sample")

write.csv(removed_samples, file = "removed_samples_75.csv", row.names = FALSE)
################################################################################
vcfR <- vcfR.80

#subset popmap to only include retained individuals
popmap_mont.unit<-popmap_mont.unit[popmap_mont.unit$id %in% colnames(vcfR@gt),]
dim(popmap_mont.unit)

#subset popmap_morphsp to only include retained individuals
popmap_morphsp<-popmap_morphsp[popmap_morphsp$id %in% colnames(vcfR@gt),]
dim(popmap_morphsp)

popmap <- pops %>% dplyr::select(Sample, Morph_Species, Monitoring.Unit)
popmap
names(popmap) <- c("id", "pop", "MU")

sample_vcfR <- popmap$id
popsample <- popmap_mont.unit$id
removed_id <- sample_vcfR[which(!sample_vcfR %in% popsample)]
removed_samples <- as_tibble(removed_id)
names(removed_samples) <- "Sample"

removed_samples <- removed_samples %>%
  left_join(pops, by = "Sample")

write.csv(removed_samples, file = "removed_samples_80.csv", row.names = FALSE)
################################################################################
vcfR <- vcfR.85

#subset popmap to only include retained individuals
popmap_mont.unit<-popmap_mont.unit[popmap_mont.unit$id %in% colnames(vcfR@gt),]
dim(popmap_mont.unit)

#subset popmap_morphsp to only include retained individuals
popmap_morphsp<-popmap_morphsp[popmap_morphsp$id %in% colnames(vcfR@gt),]
dim(popmap_morphsp)

popmap <- pops %>% dplyr::select(Sample, Morph_Species, Monitoring.Unit)
popmap
names(popmap) <- c("id", "pop", "MU")

sample_vcfR <- popmap$id
popsample <- popmap_mont.unit$id
removed_id <- sample_vcfR[which(!sample_vcfR %in% popsample)]
removed_samples <- as_tibble(removed_id)
names(removed_samples) <- "Sample"

removed_samples <- removed_samples %>%
  left_join(pops, by = "Sample")

write.csv(removed_samples, file = "removed_samples_85.csv", row.names = FALSE)
################################################################################
vcfR <- vcfR.95

#subset popmap to only include retained individuals
popmap_mont.unit<-popmap_mont.unit[popmap_mont.unit$id %in% colnames(vcfR@gt),]
dim(popmap_mont.unit)

#subset popmap_morphsp to only include retained individuals
popmap_morphsp<-popmap_morphsp[popmap_morphsp$id %in% colnames(vcfR@gt),]
dim(popmap_morphsp)

popmap <- pops %>% dplyr::select(Sample, Morph_Species, Monitoring.Unit)
popmap
names(popmap) <- c("id", "pop", "MU")

sample_vcfR <- popmap$id
popsample <- popmap_mont.unit$id
removed_id <- sample_vcfR[which(!sample_vcfR %in% popsample)]
removed_samples <- as_tibble(removed_id)
names(removed_samples) <- "Sample"

removed_samples <- removed_samples %>%
  left_join(pops, by = "Sample")

write.csv(removed_samples, file = "removed_samples_90.csv", row.names = FALSE)